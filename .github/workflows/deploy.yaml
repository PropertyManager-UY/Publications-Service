name: Continuous Deployment

on:
  workflow_run:
    workflows: ["Run Tests and Deploy"]  # Nombre del flujo de trabajo que debe completarse
    types:
      - completed

jobs:
  build-and-deploy:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}  # Solo ejecutar si las pruebas fueron exitosas
    runs-on: ubuntu-latest

    env:
      DOCKER_IMAGE_TAG: "latest"
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      K8_NAMESPACE: "property-manager"
      K8_DEPLOYMENT: "publications-deployment"
      K8_APP: "publications"
      SERVICE_NAME: "publications-service"
      HPA_NAME: "publications-hpa"
      SERVER_KUBE_CONFIG: ${{ secrets.SERVER_KUBE_CONFIG }}
      DEPLOYMENT_DIR: ${{ secrets.DEPLOYMENT_DIR }}

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v2

    - name: Create SSH directory
      run: mkdir -p ~/.ssh && chmod 700 ~/.ssh

    - name: Check and add host key to known_hosts
      run: ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts

    - name: Login to Docker Hub
      run: echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin

    - name: Build and Push Docker Image
      run: |
        docker build -t $DOCKER_USERNAME/property_manager.$SERVICE_NAME:$DOCKER_IMAGE_TAG .
        docker push $DOCKER_USERNAME/property_manager.$SERVICE_NAME:$DOCKER_IMAGE_TAG

    - name: Set up SSH for remote server access
      uses: webfactory/ssh-agent@v0.5.3
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Create Deployment Directory
      run: ssh ${{ secrets.USERNAME }}@${{ secrets.SERVER_IP }} mkdir -p ${DEPLOYMENT_DIR}/deployment-${K8_APP}

    - name: Substitute Environment Variables in Kubernetes Manifests
      run: |
        envsubst < .deploy/kubernetes/deployment.yaml > deployment.yaml
        envsubst < .deploy/kubernetes/hpa.yaml > hpa.yaml
        envsubst < .deploy/kubernetes/service.yaml > service.yaml
        scp -r deployment.yaml hpa.yaml service.yaml ${{ secrets.USERNAME }}@${{ secrets.SERVER_IP }}:${{ secrets.DEPLOYMENT_DIR }}/deployment-${K8_APP}

    - name: Create Namespace if Not Exists
      run: |
        ssh ${{ secrets.USERNAME }}@${{ secrets.SERVER_IP }} << EOF
          export KUBECONFIG=${{ secrets.SERVER_KUBE_CONFIG }}
          kubectl get namespace ${K8_NAMESPACE} || kubectl create namespace ${K8_NAMESPACE}
        EOF

    - name: Check and Create Resources if Not Exists
      id: create_resources
      run: |
        ssh ${{ secrets.USERNAME }}@${{ secrets.SERVER_IP }} << EOF
          export KUBECONFIG=${{ secrets.SERVER_KUBE_CONFIG }}
          touch ${DEPLOYMENT_DIR}/deployment-${K8_APP}/create_resources_status.txt
          if ! kubectl get deployment $K8_DEPLOYMENT --namespace=${K8_NAMESPACE}; then
            echo "creating resources" > ${DEPLOYMENT_DIR}/deployment-${K8_APP}/create_resources_status.txt
          fi
          if ! kubectl get svc $SERVICE_NAME --namespace=${K8_NAMESPACE}; then
            echo "creating resources" > ${DEPLOYMENT_DIR}/deployment-${K8_APP}/create_resources_status.txt
          fi
          if ! kubectl get hpa $HPA_NAME --namespace=${K8_NAMESPACE}; then
            echo "creating resources" > ${DEPLOYMENT_DIR}/deployment-${K8_APP}/create_resources_status.txt
          fi
        EOF

    - name: Create Kubernetes Resources if Not Exists
      if: steps.create_resources.outputs.create_resources_status == 'creating resources'
      run: |
        ssh ${{ secrets.USERNAME }}@${{ secrets.SERVER_IP }} << EOF
          export KUBECONFIG=${{ secrets.SERVER_KUBE_CONFIG }}
          kubectl apply -f ${{ secrets.DEPLOYMENT_DIR }}/deployment-${K8_APP} --namespace=${K8_NAMESPACE}
        EOF

    - name: Update Kubernetes Deployment
      if: steps.create_resources.outputs.create_resources_status != 'creating resources'
      run: |
        ssh ${{ secrets.USERNAME }}@${{ secrets.SERVER_IP }} << EOF
          export KUBECONFIG=${{ secrets.SERVER_KUBE_CONFIG }}
          kubectl set image deployment/$K8_DEPLOYMENT $SERVICE_NAME=$DOCKER_USERNAME/property_manager.$SERVICE_NAME:$DOCKER_IMAGE_TAG --namespace=${K8_NAMESPACE}
        EOF

    - name: Clean Deployment Cache
      run: |
        ssh ${{ secrets.USERNAME }}@${{ secrets.SERVER_IP }} << EOF
          rm -rf ${{ secrets.DEPLOYMENT_DIR }}/deployment-${K8_APP}
        EOF
